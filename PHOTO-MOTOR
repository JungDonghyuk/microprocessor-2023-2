uint16_t read_ADC(uint8_t channel) {
  ADMUX = (ADMUX & 0xF0) | (channel & 0x0F);
  ADCSRA |= (1 << ADSC);
  while (ADCSRA & (1 << ADSC));
  return ADC;
}

void setup(){
  init_Serial();
  init_ADC();
  Serial.begin(9600);
  while (!Serial) {
    ; 
  }
  SPI.begin(); 
  pinMode(MOSI, OUTPUT); 
  pinMode(SCK, OUTPUT);
  pinMode(9, OUTPUT);
  SPCR |= (1 << SPE) | (1 << MSTR) | (0 << SPR1) | ( 1<< SPR0);
  pinMode(7, OUTPUT); //얘는 보내는 핀임!!!
}

void loop(){
  uint16_t value1 = read_ADC(0); //시작점의 조도센서 값이라고 가정함
  uint16_t value2 = read_ADC(1); //도착점의 조도센서 값이라고 가정함
  uint16_t base1 = 400; //400은 실제로 해보고 수정이 필요함
  uint16_t base2 = 600; //400은 실제로 해보고 수정이 필요함

  Serial.println(value2);

  if((uint16_t value1 < base1) & (uint16_t value2 < base2)){
    //시작하는 코드(타이머, 조이스틱 구동)
    //둘다 열려있음, 즉, 공이 미로 안에 존재함

    digitalWrite(7, HIGH); //보내는 핀의
    
    uint16_t NUM_ON = 0; 
    DDRB = 0xFF;


    uint16_t POS_VAL = pow(2, NUM_MOTORS) - 1;
    uint16_t value = random(0, POS_VAL);

    for (uint8_t i = 0; i < 16; i++) {
      NUM_ON += (value >> (15 - i)) & 0x01;
    }

    if (NUM_ON > 10) {
     uint8_t lByte = (value >> 8);
      uint8_t hByte = (value & 0xff);
      Serial.println(lByte);

      //slave1 켜고
      digitalWrite(SS_1, LOW); 
      SPI.transfer(lByte); 
      digitalWrite(SS_1, HIGH);
      //바로 slave2
      digitalWrite(SS_2, LOW); 
      SPI.transfer(hByte); 
      digitalWrite(SS_2, HIGH); 
      
      delay(1000);//벽 바꾸는 주기
  }
    
  }
  else if ((uint16_t value1 < base1) & (uint16_t value2 > base2)){
    //도착점에 공이 들어와서 조도센서2가 가려짐.
    // 마무리코드
    // 추후에 추가할 사항(모터제어에 대해서)이 있으면, 물결이든, 어려우면 다 꺼버리던 하는 코드를 작성할 것. 
    digitalWrite(7, LOW);
  }

  delay(10);  //없애야할 수도 있음.
}
